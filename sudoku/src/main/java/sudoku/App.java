/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package sudoku;

import com.googlecode.lanterna.*;
import com.googlecode.lanterna.TextColor.ANSI;
import com.googlecode.lanterna.graphics.TextGraphics;
import com.googlecode.lanterna.input.KeyStroke;
import com.googlecode.lanterna.input.KeyType;
import com.googlecode.lanterna.screen.Screen;
import com.googlecode.lanterna.terminal.DefaultTerminalFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class App {

    enum Direction { Left, Right; }
    enum Mode { Game, Save, Load; }

    private static final int GRID_ROWS = 19;
    private static final int GRID_COLS = 37;
    private static final int CANVAS_ROWS = GRID_ROWS + 3;
    private static final int CANVAS_COLS = GRID_COLS + 4;

    private static final String TOP_BORDER    = "╔═══╤═══╤═══╦═══╤═══╤═══╦═══╤═══╤═══╗";
    private static final String NUMBER_ROW    = "║   ·   ·   ║   ·   ·   ║   ·   ·   ║";
    private static final String SINGLE_GRID   = "╟───┼───┼───╫───┼───┼───╫───┼───┼───╢";
    private static final String DOUBLE_GRID   = "╠═══╪═══╪═══╬═══╪═══╪═══╬═══╪═══╪═══╣";
    private static final String BOTTOM_BORDER = "╚═══╧═══╧═══╩═══╧═══╧═══╩═══╧═══╧═══╝";

    private static final String AUTO_SAVE_FILE = ".sudoku.autosave";

    private static final Map<Mode, String> PROMPT = new HashMap<Mode, String>() {
        private static final long serialVersionUID = 1L;
        {
            put(Mode.Game, "");
            put(Mode.Save, "saving to: ");
            put(Mode.Load, "load from: ");
        }
    };

    private static final ANSI BASE_BACK   = ANSI.BLACK;
    private static final ANSI BASE_FORE   = ANSI.CYAN;
    private static final ANSI COL_BACK    = ANSI.BLUE;
    private static final ANSI COL_FORE    = ANSI.BLACK;
    private static final ANSI ROW_BACK    = ANSI.GREEN;
    private static final ANSI ROW_FORE    = ANSI.BLACK;
    private static final ANSI REGION_BACK = ANSI.MAGENTA;
    private static final ANSI REGION_FORE = ANSI.BLACK;
    private static final ANSI CORE_BACK   = ANSI.WHITE;
    private static final ANSI CORE_FORE   = ANSI.RED;
    private static final ANSI ERROR_BACK  = ANSI.RED;
    private static final ANSI ERROR_FORE  = ANSI.WHITE;

    private static final DefaultTerminalFactory defaultTerminalFactory = new DefaultTerminalFactory();

    private static final int[][] LINE = {{-2, -1, GRID_COLS + 1, -1},
                                        {-2, GRID_ROWS + 1, GRID_COLS + 1, GRID_ROWS + 1},
                                        {-2, 0, -2, GRID_ROWS},
                                        {-1, 0, -1, GRID_ROWS},
                                        {GRID_COLS, 0, GRID_COLS, GRID_ROWS},
                                        {GRID_COLS + 1, 0, GRID_COLS + 1, GRID_ROWS}};

    private int editIndex = 0;
    private int cursorCol = 4;
    private int cursorRow = 4;
    private int[][] sudokuMap = {{0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0}};

    private Mode gamemode = Mode.Load;
    private StringBuilder savename = new StringBuilder();

    private Screen screen;
    private TerminalSize terminalSize;
    private TerminalPosition leftTopPosition;
    private TextGraphics gridTextGraphics;

    public static void main(String[] args) {
        new App().runSudoku();
    }

    private void runSudoku() {
        try {
            setup();
            loop();
        } catch (IOException e) {
            rescue(e);
        } finally {
            clean();
        }
    }

    private void setup() throws IOException {
        screen = defaultTerminalFactory.createScreen();
        screen.startScreen();
        terminalSize = screen.getTerminalSize();
        refreshPosition();
        autoLoad();
        paintSudoku();
    }

    private void loop() throws IOException {
        while (handleInput()) handleRepaint();
    }

    private void rescue(Exception e) {
        e.printStackTrace();
    }

    private void clean() {
        if (screen != null) try { screen.close(); autoSave();} catch (Exception e) { rescue(e); }
    }

    private void handleRepaint() throws IOException {
        TerminalSize newTerminalSize = screen.doResizeIfNecessary();
        if (newTerminalSize != null) {
            terminalSize = newTerminalSize;
            refreshPosition();
            paintSudoku();
        }
    }

    private Boolean handleInput() throws IOException {
        KeyStroke keyStroke = screen.pollInput();
        if (keyStroke != null) {
            KeyType keyType = keyStroke.getKeyType();
            if (gamemode.equals(Mode.Game)) {
                switch (keyType) {
                    case EOF:
                    case Escape: return false;
                    case ArrowUp: drawCursor(0, -1); break;
                    case ArrowDown: drawCursor(0, 1); break;
                    case ArrowLeft: drawCursor(-1, 0); break;
                    case ArrowRight: drawCursor(1, 0); break;
                    case Character:
                        Character character = keyStroke.getCharacter();
                        switch (character) {
                            case 's': toggleMode(Mode.Save); break;
                            case 'l': toggleMode(Mode.Load); break;
                            case 'r': inputReset(); break;
                            default: if (character >= '0' && character <= '9') inputNumber(character);
                        }
                    default:
                }
            } else {
                switch (keyType) {
                    case EOF: return false;
                    case Escape: toggleMode(Mode.Game); break;
                    case Backspace: deleteChar(Direction.Left); break;
                    case Delete: deleteChar(Direction.Right); break;
                    case ArrowLeft: moveIndex(Direction.Left); break;
                    case ArrowRight: moveIndex(Direction.Right); break;
                    case Character: insertChar(keyStroke.getCharacter()); break;
                    case Enter: submitEdit();
                    default:
                }
            }
            screen.refresh();
        }
        Thread.yield();
        return true;
    }

    private void autoSave() {
        gamemode = Mode.Save;
        File saveFile = new File(AUTO_SAVE_FILE);
        try {
            Boolean created = saveFile.createNewFile();
            try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(saveFile))) {
                oos.writeObject(sudokuMap);
            } catch (Exception e) {
                if (created) saveFile.delete();
            }
        } catch (Exception e) { }
    }

    private void autoLoad() {
        File saveFile = new File(AUTO_SAVE_FILE);
        try {
            Boolean created = saveFile.createNewFile();
            try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(saveFile))) {
                sudokuMap = (int[][]) ois.readObject();
            } catch (Exception e) {
                if (created) saveFile.delete();
            }
        } catch (Exception e) { }
        gamemode = Mode.Game;
        savename = new StringBuilder();
        editIndex = 0;
    }

    private void submitEdit() {
        File saveFile = new File(savename.toString() + ".dat");
        Boolean created = false;
        try {
            created = saveFile.createNewFile();
        } catch (IOException e) { }
        switch (gamemode) {
            case Save:
                try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(saveFile))) {
                    oos.writeObject(sudokuMap);
                    toggleMode(Mode.Game);
                    drawPrompt("               Success!");
                } catch (Exception e) {
                    drawPrompt("            Failed to save.");
                    if (created) saveFile.delete();
                }
                break;
            case Load:
                try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(saveFile))) {
                    sudokuMap = (int[][]) ois.readObject();
                    gamemode = Mode.Game;
                    drawSudoku();
                    drawPrompt("               Success!");
                } catch (Exception e) {
                    drawPrompt("            Failed to load.");
                    if (created) saveFile.delete();
                }
            default:
        }
        screen.setCursorPosition(null);
    }

    private void toggleMode(Mode newMode) {
        gamemode = newMode;
        savename = new StringBuilder();
        editIndex = 0;
        if (gamemode.equals(Mode.Game)) drawHint(); else drawPrompt();
    }

    private void deleteChar(Direction direction) {
        switch (direction) {
            case Left: if (editIndex > 0) savename.deleteCharAt(editIndex-- - 1); break;
            case Right: if (editIndex < savename.length()) savename.deleteCharAt(editIndex);
        }
        drawPrompt();
    }

    private void moveIndex(Direction direction) {
        switch (direction) {
            case Left: editIndex = Math.max(0, --editIndex); break;
            case Right: editIndex = Math.min(Math.min(GRID_COLS - PROMPT.get(gamemode).length(), savename.length()), ++editIndex);
        }
        drawPrompt();
    }

    private void insertChar(char character) {
        if (savename.length() < GRID_COLS - PROMPT.get(gamemode).length()) savename.insert(editIndex++, character);
        drawPrompt();
    }

    private void inputReset() {
        for (int[] is : sudokuMap) Arrays.fill(is, 0);
        drawBoard();
        drawCursor();
    }

    private void inputNumber(Character character) {
        sudokuMap[cursorRow][cursorCol] = character - '0';
        if (character == '0') character = ' ';
        screen.setCharacter(leftTopPosition.withRelative(4 *cursorCol + 2, 2 * cursorRow + 1),
            new TextCharacter(character));
        drawHint();
        drawCursor();
    }

    private void paintSudoku() throws IOException {
        screen.clear();
        gridTextGraphics = screen.newTextGraphics();
        gridTextGraphics.setBackgroundColor(ANSI.BLACK);
        gridTextGraphics.setForegroundColor(ANSI.CYAN);
        if (terminalSize.getColumns() >= CANVAS_COLS && terminalSize.getRows() >= CANVAS_ROWS)
            drawSudoku();
        else drawWarning();
        screen.refresh();
    }

    private void drawSudoku() {
        drawBoard();
        drawPiece();
        drawHint();
        drawCursor();
    }

    private void drawBoard() {
        String rowString;
        gridTextGraphics.putString(leftTopPosition, TOP_BORDER);
        for (int row = 1; row < GRID_ROWS - 1; row++) {
            if (row % 6 == 0) rowString = DOUBLE_GRID;
            else if (row % 2 == 0) rowString = SINGLE_GRID;
            else rowString = NUMBER_ROW;
            gridTextGraphics.putString(
                leftTopPosition.withRelativeRow(row), rowString);
        }
        gridTextGraphics.putString(
            leftTopPosition.withRelativeRow(GRID_ROWS - 1), BOTTOM_BORDER);
    }

    private void drawPiece() {
        for (int row = 0; row < sudokuMap.length; row++)
            for (int col = 0; col < sudokuMap[row].length; col++)
                if (sudokuMap[row][col] > 0)
                    gridTextGraphics.setCharacter(
                        leftTopPosition.withRelative(4 * col + 2, 2 * row + 1),
                        (char)('0' + sudokuMap[row][col]));
    }

    private void drawHint() {
        for (int[] is : LINE)
            gridTextGraphics.drawLine(leftTopPosition.withRelative(is[0], is[1]),
                leftTopPosition.withRelative(is[2], is[3]), '▓');
        gridTextGraphics.putString(leftTopPosition.withRelative(0, GRID_ROWS), "Esc退出|r重置|1-9输入|0 清空|↑↓←→导航");
        gridTextGraphics.putString(leftTopPosition.withRelative(4, GRID_ROWS + 1), "s保存|l载入|Enter确定|Esc取消");
        screen.setCursorPosition(null);
    }

    private void drawPrompt(String content) {
        gridTextGraphics.putString(leftTopPosition.withRelative(0, -1), String.format("%1$-" + GRID_COLS + "s", content));
        screen.setCursorPosition(leftTopPosition.withRelative(0 + PROMPT.get(gamemode).length() + editIndex, -1));
    }

    private void drawPrompt() {
        drawPrompt(PROMPT.get(gamemode) + savename.toString());
    }

    private void drawCursor(int deltaCol, int deltaRow) {
        if (cursorCol == 8 && deltaCol > 0 || cursorCol == 0 && deltaCol < 0) deltaCol = 0;
        if (cursorRow == 8 && deltaRow > 0 || cursorRow == 0 && deltaRow < 0) deltaRow = 0;
        if (deltaCol != 0 || deltaRow != 0) flipStyle(false);
        cursorCol += deltaCol;
        cursorRow += deltaRow;
        flipStyle(true);
        drawHint();
    }

    private void drawCursor() {
        flipStyle(true);
    }

    private void drawWarning() {
        gridTextGraphics.putString(new TerminalPosition(0, 0),
            String.format("终端尺寸过小，请确保至少为%dx%d（当前为：%dx%d）",
                CANVAS_COLS, CANVAS_ROWS, terminalSize.getColumns(), terminalSize.getRows()));
    }

    private void flipStyle(Boolean stylish) {
        fillStyle(0, 2 * cursorRow + 1, GRID_COLS, 1, ROW_BACK, ROW_FORE, stylish);
        fillStyle(4 * cursorCol + 1, 0, 3, GRID_ROWS, COL_BACK, COL_FORE, stylish);
        fillStyle(12 * (cursorCol / 3) + 1, 6 * (cursorRow / 3) + 1, 11, 5, REGION_BACK, REGION_FORE, stylish);
        fillStyle(4 * cursorCol + 1, 2 * cursorRow + 1, 3, 1, CORE_BACK, CORE_FORE, stylish);
        int currentNumber = sudokuMap[cursorRow][cursorCol];
        if (stylish && currentNumber != 0) {
            for (int row = 0; row < sudokuMap.length; row++)
                if (currentNumber == sudokuMap[row][cursorCol] && row != cursorRow)
                    fillStyle(4 * cursorCol + 1, 2 * row + 1, 3, 1, ERROR_BACK, ERROR_FORE, stylish);
            for (int col = 0; col < sudokuMap[cursorRow].length; col++)
                if (currentNumber == sudokuMap[cursorRow][col] && col != cursorCol)
                    fillStyle(4 * col + 1, 2 * cursorRow + 1, 3, 1, ERROR_BACK, ERROR_FORE, stylish);
            for (int row = 3 * (cursorRow / 3); row < 3 * (cursorRow / 3) + 3; row++)
                for (int col = 3 * (cursorCol / 3); col < 3 * (cursorCol / 3) + 3 ; col++)
                    if (currentNumber == sudokuMap[row][col] && row != cursorRow && col != cursorCol)
                        fillStyle(4 * col + 1, 2 * row + 1, 3, 1, ERROR_BACK, ERROR_FORE, stylish);
        }
    }

    private void fillStyle(int left, int top, int deltaX, int deltaY, ANSI back, ANSI fore, Boolean stylish) {
        for (int row = top; row < top + deltaY; row++)
            for (int col = left; col < left + deltaX; col++)
                screen.setCharacter(leftTopPosition.withRelative(col, row),
                    screen.getBackCharacter(leftTopPosition.withRelative(col, row))
                        .withBackgroundColor(stylish ? back : BASE_BACK)
                        .withForegroundColor(stylish ? fore : BASE_FORE));
    }

    private void refreshPosition() {
        leftTopPosition = new TerminalPosition(
            (terminalSize.getColumns() - CANVAS_COLS) / 2 + 2,
            (terminalSize.getRows() - CANVAS_ROWS) / 2 + 1);
    }
}
