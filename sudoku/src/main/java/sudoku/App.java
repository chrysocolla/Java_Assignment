/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package sudoku;

import com.googlecode.lanterna.*;
import com.googlecode.lanterna.TextColor.ANSI;
import com.googlecode.lanterna.graphics.TextGraphics;
import com.googlecode.lanterna.input.KeyStroke;
import com.googlecode.lanterna.input.KeyType;
import com.googlecode.lanterna.screen.Screen;
import com.googlecode.lanterna.terminal.DefaultTerminalFactory;

import java.io.IOException;

public class App {
    private static final int MIN_ROWS = 20;
    private static final int MIN_COLS = 2 * MIN_ROWS;

    private static final String TOP_BORDER    = "╔═══╤═══╤═══╦═══╤═══╤═══╦═══╤═══╤═══╗";
    private static final String NUMBER_ROW    = "║   |   |   ║   |   |   ║   |   |   ║";
    private static final String SINGLE_GRID   = "╟───┼───┼───╫───┼───┼───╫───┼───┼───╢";
    private static final String DOUBLE_GRID   = "╠═══╪═══╪═══╬═══╪═══╪═══╬═══╪═══╪═══╣";
    private static final String BOTTOM_BORDER = "╚═══╧═══╧═══╩═══╧═══╧═══╩═══╧═══╧═══╝";

    private static final DefaultTerminalFactory defaultTerminalFactory = new DefaultTerminalFactory();

    private Screen screen = null;
    public static void main(String[] args) {
        new App().runSudoku();
    }

    private void runSudoku() {
        try {
            screen = defaultTerminalFactory.createScreen();
            screen.startScreen();
            screen.setCursorPosition(null);
            TerminalSize terminalSize = screen.getTerminalSize();
            plotBackground(screen, terminalSize);

            while (true) {
                TerminalSize newTerminalSize = screen.doResizeIfNecessary();
                if (newTerminalSize != null) {
                    terminalSize = newTerminalSize;
                    plotBackground(screen, terminalSize);
                }
                KeyStroke keyStroke = screen.pollInput();
                if (keyStroke != null) {
                    if (keyStroke.getKeyType() == KeyType.Escape || keyStroke.getKeyType() == KeyType.EOF) {
                        break;
                    }
                    switch (keyStroke.getKeyType()) {
                        case ArrowUp:
                            
                            break;
                        case ArrowDown:
                            
                            break;
                        case ArrowLeft:
                            
                            break;
                        case ArrowRight:
                            
                            break;
                    
                        default:
                            break;
                    }
                    screen.refresh();
                }
                Thread.yield();
            }
        } catch(IOException e) {
            e.printStackTrace();
        } finally {
            if(screen != null) {
                try {
                    screen.close();
                }
                catch(IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private static void plotBackground(Screen screen, TerminalSize terminalSize) throws IOException {
        screen.clear();
        TextGraphics backgroundTextGraphics = screen.newTextGraphics();
        backgroundTextGraphics.setBackgroundColor(ANSI.BLACK);
        backgroundTextGraphics.setForegroundColor(ANSI.CYAN);
        if (terminalSize.getColumns() >= MIN_COLS && terminalSize.getRows() >= MIN_ROWS ) {
            plotGrid(backgroundTextGraphics, terminalSize);
        } else {
            plotWarning(backgroundTextGraphics, terminalSize);
        }
        screen.refresh();
        screen.setCursorPosition(null);
    }

    private static void plotGrid(TextGraphics backgroundTextGraphics, TerminalSize terminalSize) throws IOException {
        TerminalPosition leftTopTerminalPosition = new TerminalPosition(
            (terminalSize.getColumns() - MIN_COLS ) / 2,
            (terminalSize.getRows() - MIN_ROWS ) / 2
        );
        backgroundTextGraphics.fillRectangle(
            leftTopTerminalPosition,
            new TerminalSize(MIN_COLS - 4, MIN_ROWS - 2),
            ' '
        );
        backgroundTextGraphics.putString(
            leftTopTerminalPosition,
            TOP_BORDER
        );
        for (int row = 1; row < MIN_ROWS - 2; row++) {
            String rowString;
            if (row % 6 == 0) {
                rowString = DOUBLE_GRID;
            } else if (row % 2 == 0) {
                rowString = SINGLE_GRID;
            } else {
                rowString = NUMBER_ROW;
            }
            backgroundTextGraphics.putString(
                leftTopTerminalPosition.withRelativeRow(row),
                rowString
            );
        }
        backgroundTextGraphics.putString(
            leftTopTerminalPosition.withRelativeRow(MIN_ROWS - 2),
            BOTTOM_BORDER
        );

    }

    private static void plotWarning(TextGraphics backgroundTextGraphics, TerminalSize terminalSize) throws IOException {
        backgroundTextGraphics.putString(
            new TerminalPosition(0, 0),
            String.format(
                "终端尺寸过小，请确保至少为38x20（当前为：%dx%d）",
                terminalSize.getColumns(),
                terminalSize.getRows()
            )
        );
    }
}
