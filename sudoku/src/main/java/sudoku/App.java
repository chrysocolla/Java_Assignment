/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package sudoku;

import com.googlecode.lanterna.*;
import com.googlecode.lanterna.TextColor.ANSI;
import com.googlecode.lanterna.graphics.TextGraphics;
import com.googlecode.lanterna.input.KeyStroke;
import com.googlecode.lanterna.input.KeyType;
import com.googlecode.lanterna.screen.Screen;
import com.googlecode.lanterna.terminal.DefaultTerminalFactory;

import java.io.IOException;
import java.util.Arrays;

public class App {
    private static final int GRID_ROWS = 19;
    private static final int GRID_COLS = 37;
    private static final int CANVAS_ROWS = GRID_ROWS + 3;
    private static final int CANVAS_COLS = GRID_COLS + 4;

    private static final String TOP_BORDER    = "╔═══╤═══╤═══╦═══╤═══╤═══╦═══╤═══╤═══╗";
    private static final String NUMBER_ROW    = "║   ·   ·   ║   ·   ·   ║   ·   ·   ║";
    private static final String SINGLE_GRID   = "╟───┼───┼───╫───┼───┼───╫───┼───┼───╢";
    private static final String DOUBLE_GRID   = "╠═══╪═══╪═══╬═══╪═══╪═══╬═══╪═══╪═══╣";
    private static final String BOTTOM_BORDER = "╚═══╧═══╧═══╩═══╧═══╧═══╩═══╧═══╧═══╝";

    private static final ANSI BASE_BACK   = ANSI.BLACK;
    private static final ANSI BASE_FORE   = ANSI.CYAN;
    private static final ANSI COL_BACK    = ANSI.BLUE;
    private static final ANSI COL_FORE    = ANSI.BLACK;
    private static final ANSI ROW_BACK    = ANSI.GREEN;
    private static final ANSI ROW_FORE    = ANSI.BLACK;
    private static final ANSI REGION_BACK = ANSI.MAGENTA;
    private static final ANSI REGION_FORE = ANSI.BLACK;
    private static final ANSI CORE_BACK   = ANSI.WHITE;
    private static final ANSI CORE_FORE   = ANSI.RED;
    private static final ANSI ERROR_BACK  = ANSI.RED;
    private static final ANSI ERROR_FORE  = ANSI.WHITE;

    private static final DefaultTerminalFactory defaultTerminalFactory = new DefaultTerminalFactory();

    private int cursorCol = 4;
    private int cursorRow = 4;
    private int[][] sudokuMap = {{0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                                {0, 0, 0, 0, 0, 0, 0, 0, 0}};

    private Screen screen;
    private TerminalSize terminalSize;
    private TerminalPosition leftTopPosition;
    private TextGraphics gridTextGraphics;

    public static void main(String[] args) {
        new App().runSudoku();
    }

    private void runSudoku() {
        try {
            setup();
            loop();
        } catch (IOException e) {
            rescue(e);
        } finally {
            clean();
        }
    }

    private void setup() throws IOException {
        screen = defaultTerminalFactory.createScreen();
        screen.startScreen();
        terminalSize = screen.getTerminalSize();
        refreshPosition();
        paintSudoku();
    }

    private void loop() throws IOException {
        while (handleInput()) handleRepaint();
    }

    private void rescue(Exception e) {
        e.printStackTrace();
    }

    private void clean() {
        if (screen != null) try { screen.close(); } catch (IOException e) { rescue(e); }
    }

    private void handleRepaint() throws IOException {
        TerminalSize newTerminalSize = screen.doResizeIfNecessary();
        if (newTerminalSize != null) {
            terminalSize = newTerminalSize;
            refreshPosition();
            paintSudoku();
        }
    }

    private Boolean handleInput() throws IOException {
        KeyStroke keyStroke = screen.pollInput();
        if (keyStroke != null) {
            if (keyStroke.getKeyType() == KeyType.Escape || keyStroke.getKeyType() == KeyType.EOF)
                return false;
            switch (keyStroke.getKeyType()) {
                case ArrowUp:
                    drawCursor(0, cursorRow == 0 ? 0 : -1);
                    break;
                case ArrowDown:
                    drawCursor(0, cursorRow == 8 ? 0 : 1);
                    break;
                case ArrowLeft:
                    drawCursor(cursorCol == 0 ? 0 : -1, 0);
                    break;
                case ArrowRight:
                    drawCursor(cursorCol == 8 ? 0 : 1, 0);
                    break;
                case Character:
                    Character character = keyStroke.getCharacter();
                    if (character >= '0' && character <= '9') inputNumber(character);
                    else if (character == 'r') inputReset();
                default:
            }
            screen.refresh();
            screen.setCursorPosition(null);
        }
        Thread.yield();
        return true;
    }

    private void inputNumber(Character character) {
        sudokuMap[cursorRow][cursorCol] = character - '0';
        if (character == '0') character = ' ';
        screen.setCharacter(leftTopPosition.withRelative(4 *cursorCol + 2, 2 * cursorRow + 1),
            new TextCharacter(character));
        drawCursor(0, 0);
    }

    private void inputReset() {
        for (int[] is : sudokuMap) Arrays.fill(is, 0);
        drawBoard();
        drawCursor(0, 0);
    }

    private void paintSudoku() throws IOException {
        screen.clear();
        gridTextGraphics = screen.newTextGraphics();
        gridTextGraphics.setBackgroundColor(ANSI.BLACK);
        gridTextGraphics.setForegroundColor(ANSI.CYAN);
        if (terminalSize.getColumns() >= CANVAS_COLS && terminalSize.getRows() >= CANVAS_ROWS )
            drawSudoku();
        else drawWarning();
        screen.refresh();
        screen.setCursorPosition(null);
    }

    private void drawSudoku() {
        drawBoard();
        drawPiece();
        drawHint();
        drawCursor(0, 0);
    }

    private void drawBoard() {
        String rowString;
        gridTextGraphics.putString(leftTopPosition, TOP_BORDER);
        for (int row = 1; row < GRID_ROWS - 1; row++) {
            if (row % 6 == 0) rowString = DOUBLE_GRID;
            else if (row % 2 == 0) rowString = SINGLE_GRID;
            else rowString = NUMBER_ROW;
            gridTextGraphics.putString(
                leftTopPosition.withRelativeRow(row), rowString);
        }
        gridTextGraphics.putString(
            leftTopPosition.withRelativeRow(GRID_ROWS - 1), BOTTOM_BORDER);
    }

    private void drawPiece() {
        for (int row = 0; row < sudokuMap.length; row++)
            for (int col = 0; col < sudokuMap[row].length; col++)
                if (sudokuMap[row][col] > 0)
                    gridTextGraphics.setCharacter(
                        leftTopPosition.withRelative(4 * col + 2, 2 * row + 1),
                        (char)('0' + sudokuMap[row][col]));
    }

    private void drawHint() {
        gridTextGraphics.drawLine(leftTopPosition.withRelative(-2, -1), leftTopPosition.withRelative(38, -1), '▓');
        gridTextGraphics.drawLine(leftTopPosition.withRelative(-2, 20), leftTopPosition.withRelative(38, 20), '▓');
        gridTextGraphics.drawLine(leftTopPosition.withRelative(-2, 0), leftTopPosition.withRelative(-2, 19), '▓');
        gridTextGraphics.drawLine(leftTopPosition.withRelative(-1, 0), leftTopPosition.withRelative(-1, 19), '▓');
        gridTextGraphics.drawLine(leftTopPosition.withRelative(37, 0), leftTopPosition.withRelative(37, 19), '▓');
        gridTextGraphics.drawLine(leftTopPosition.withRelative(38, 0), leftTopPosition.withRelative(38, 19), '▓');
        gridTextGraphics.putString(leftTopPosition.withRelative(0, 19), "Esc退出|r重置|1-9输入|0 清空|↑↓←→导航");
    }

    private void drawCursor(int deltaCol, int deltaRow) {
        if (deltaCol != 0 || deltaRow != 0) {
            flipStyle(false);
            cursorCol += deltaCol;
            cursorRow += deltaRow;
        }
        flipStyle(true);
    }

    private void drawWarning() {
        gridTextGraphics.putString(new TerminalPosition(0, 0),
            String.format("终端尺寸过小，请确保至少为%dx%d（当前为：%dx%d）",
                CANVAS_COLS, CANVAS_ROWS, terminalSize.getColumns(), terminalSize.getRows()));
    }

    private void flipStyle(Boolean stylish) {
        fillStyle(0, 2 * cursorRow + 1, GRID_COLS, 1, ROW_BACK, ROW_FORE, stylish);
        fillStyle(4 * cursorCol + 1, 0, 3, GRID_ROWS, COL_BACK, COL_FORE, stylish);
        fillStyle(12 * (cursorCol / 3) + 1, 6 * (cursorRow / 3) + 1, 11, 5, REGION_BACK, REGION_FORE, stylish);
        fillStyle(4 * cursorCol + 1, 2 * cursorRow + 1, 3, 1, CORE_BACK, CORE_FORE, stylish);
        int currentNumber = sudokuMap[cursorRow][cursorCol];
        if (stylish && currentNumber != 0) {
            for (int row = 0; row < sudokuMap.length; row++)
                if (currentNumber == sudokuMap[row][cursorCol] && row != cursorRow)
                    fillStyle(4 * cursorCol + 1, 2 * row + 1, 3, 1, ERROR_BACK, ERROR_FORE, stylish);
            for (int col = 0; col < sudokuMap[cursorRow].length; col++)
                if (currentNumber == sudokuMap[cursorRow][col] && col != cursorCol)
                    fillStyle(4 * col + 1, 2 * cursorRow + 1, 3, 1, ERROR_BACK, ERROR_FORE, stylish);
            for (int row = 3 * (cursorRow / 3); row < 3 * (cursorRow / 3) + 3; row++)
                for (int col = 3 * (cursorCol / 3); col < 3 * (cursorCol / 3) + 3 ; col++)
                    if (currentNumber == sudokuMap[row][col] && row != cursorRow && col != cursorCol)
                        fillStyle(4 * col + 1, 2 * row + 1, 3, 1, ERROR_BACK, ERROR_FORE, stylish);
        }
    }

    private void fillStyle(int left, int top, int deltaX, int deltaY, ANSI back, ANSI fore, Boolean stylish) {
        for (int row = top; row < top + deltaY; row++)
            for (int col = left; col < left + deltaX; col++)
                screen.setCharacter(leftTopPosition.withRelative(col, row),
                    screen.getBackCharacter(leftTopPosition.withRelative(col, row))
                        .withBackgroundColor(stylish ? back : BASE_BACK)
                        .withForegroundColor(stylish ? fore : BASE_FORE));
    }

    private void refreshPosition() {
        leftTopPosition = new TerminalPosition(
            (terminalSize.getColumns() - CANVAS_COLS) / 2 + 2,
            (terminalSize.getRows() - CANVAS_ROWS) / 2 + 1);
    }
}
